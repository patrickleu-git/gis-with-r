---
title: "Geographic Vector and Raster Data"
author: "Patrick Leu"
date: "2025-11-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load required packages
library(sf)
library(raster)
library(crsuggest)
library(osmdata)
library(cancensus)
library(tidyverse)

```

## Vector Data

Vector data are used to represent an object or feature that occurs somewhere on Earth and that has some kind of spatial geometry, i.e., it has a shape which can be represented by an (at least) two-dimensional coordinate that references a specific location on Earth.

The `sf` package can be used to represent different types of geometries, the book takes a closer look on (1) points, (2) lines, and (3) polygons.

```{r}

# creating a single point
point = st_point(x = c(1,2))

# inspect attributes
attributes(point)

```
The single point is a simple feature geometry (or `sfg`) object of type `POINT`, meaning that it stores x,y coordinate information and does not carry any information on the geographic coordinate system, datum, or projection associated with that point.


```{r}

# create multiple points 
p1 = st_point(x = c(5,1))
p2 = st_point(x = c(1,3))
p3 = st_point(x = c(-1,4))
p4 = st_point(x = c(3,5))
p5 = st_point(x = c(4,-1))

# can combine points to a "simple feature geometry column" via
points = st_sfc(p1, p2, p3, p4, p5)

# the points together now follow a certain coordinate reference system
attributes(points)

# plot
plot(points)

```

However, a sfc cannot store any attributes associated with the feature. Instead, create a simple feature (sf) object which can have both location and attribute data

```{r}

# create some attribute (type of infrastructure)
pt_attributes = tibble(
  infrastructure = c(rep("bridge", 2), rep("bus station", 2), "park")
  )

# convert into sf object
points_sf = st_sf(pt_attributes, geometry = points)

# plot again
plot(points_sf, pch = 16, key.width = lcm(4.5))

```

Lines can be created as the same objects as the points above but they follow the `linestring` geometry, which is built from a matrix.

```{r}

# generate some random matrix
set.seed(1234)
X = matrix(sample(rep(1:5, 5), 10), ncol = 2, nrow = 5)

# create linestring sfg
linie = st_linestring(X)

# plot
plot(linie, col = "dodgerblue3", lwd = 2, lty = 3)
```
Create an sfc with multiple lines and the coordinate reference system "World Geodetic System 1984" (WGS 1984).

```{r}

# create more lines
l1 = linie
l2 = st_linestring(X-3)
l3 = st_linestring(X-X[,2]+1)

# combine to sfc
lines = st_sfc(l1, l2, l3, crs = 4326)

plot(lines)
```
We can again assign attributes to the lines, e.g., the lines could represent different road types, and cars are only allowed on high ways.

```{r}
line_attr = data.frame(
  raodt = c("bicycle road", "foot path", "high way"),
  cars_allowed = c(0, 0, 1))

lines_sf = st_sf(line_attr, geometry = lines)

plot(lines_sf["raodt"])
```
Finally, polygons are basically linestrings, where the first and last vertex coincide, i.e, are on the same coordinate. The function `st_polygon()` takes a list as input which contains linestring matrices.

```{r}

# create a matrix with top and bottom column (1,1)
set.seed(123)
polym = rbind(c(1,1), matrix(sample(rep(1:6, 4), 10), ncol = 2), c(1,1))

# create list
polyl = list(polym)

# to sfg
polyg = st_polygon(polyl)

plot(polyg, col = "dodgerblue3")
```
We can also create a hole in the polygon by creating another polygon that occurs within the first polygon, and adding it to the list. E.g., the first polygon could represent a lake and the "hole" an isle in it.

```{r}

# isle matrix
isle = rbind(c(2.5, 3.5), c(3.5, 3.75), c(3, 3.25), c(2.5, 3.5))
lake_isle = list(polym, isle)
poly_lake_isle = st_polygon(lake_isle)
plot(poly_lake_isle, col = "dodgerblue3")
```
Creating an sf wtih multiple polygons, say, multiple lakes on a high altitude plain.

```{r}

set.seed(123)
lake2 = rbind(c(5,4), matrix(sample(rep(5:8, 4), 10), ncol = 2), c(5,4)) |> list() |> st_polygon()

lake_attr = data.frame(depth = c("deep", "shallow"))

lakes_sf = st_sf(lake_attr, geometry = st_sfc(poly_lake_isle, lake2, crs = 4326))

plot(lakes_sf)

```
In summary, there are:
1. `sfg` objects contain information about a single feature geometry.
2. `sfc` objects contain multiple `sfg` objects and a coordinate reference system.
3. `sf` objects store the respective attribute data to the geometry in sfc


## Raster Data

Generally, raster data follow a grid structure with equally spaced cells. Each cell stores in input, which can correspond to categoric or numerical values. For example, it can represent elevation level, land cover type including urban sprawl, distribution of wealth by commune etc. 

The crucial parameter is spatial resolution, i.e., the size of the cells constituting the grid. The higher the resolution, the smaller the individual cells.

We can create a rectangular grid with each cell being 100mx100m in size that covers the area of Switzerland.

```{r}

ch_raster <- raster(resolution=10000, #specify spatial resolution
                     xmn=2450000, xmx=2850000, #specify extent from east to west in metres
                     ymn=1050000, ymx=1300000, #specify extent from north to south in metres
                     crs=2056) #set projection LV95 in EPSG

# generate random values
values(ch_raster) = rnorm(n = ncell(ch_raster))

# plot the raster
plot(ch_raster)
```

## Read Spatial Data

```{r}


```


## Dynamic Maps with Mapview

```{r}


``` 


